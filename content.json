{"meta":{"title":"小林的个人博客","subtitle":"","description":"","author":"林得平","url":"http://example.com","root":"/"},"pages":[{"title":"文章分类","date":"2020-11-28T12:37:45.000Z","updated":"2020-11-28T12:39:35.470Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-12-14T09:20:53.879Z","updated":"2020-12-14T09:20:53.879Z","comments":true,"path":"categories/VUEJS学习笔记（视频学习）.html","permalink":"http://example.com/categories/VUEJS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%EF%BC%89.html","excerpt":"","text":"VUEJS学习笔记（视频学习）一、计算属性&amp;&amp;过滤器1.计算属性1234computed: &#123; fullname: function()&#123; return *this*.fristname+&#x27; &#x27;+*this*.lastname; &#125; &lt;div id=&quot;app&quot;&gt;&#123;&#123;fullname&#125;&#125;&lt;/div&gt;计算属性当做属性来使用，不要当做函数来使用，所以不需要加括号 上面的写法其实是一种简写，完整的计算属性在下面 123456789computed: &#123; fullname: &#123; set: function(data)&#123;//data参数是跟着视频在浏览器的控制台给fullname赋值传过来的 console.log(&quot;-----------&quot;+data); &#125;, get: function()&#123; return this.fristname+&#x27; &#x27;+this.lastname; &#125;&#125; 一般set不会用到，上面简写的方法默认执行的是get 2.过滤器1234filters: &#123; showPrice(price) &#123; return &#x27;￥&#x27;+price.toFixed(2); &#125; &#123;&#123;item.price | showPrice&#125;&#125;,用&#39;|&#39;隔开，后面写过滤器的名字，Vue会默认将&#39;|&#39;左边的数据传给右边作为参数 注：计算属性会缓存，函数就不会多次执行，而如果使用methods来实现同样的功能的话，函数会被多次调用。二、事件监听1.事件绑定时的括号v-on:click=”fun”/语法糖-&gt;@click=”fun”,事件调用，不需要传参的时候可以吧括号省略 和普通函数一样，但需要一个参数，事件绑定时，加了括号，但是没有传的时候，就会默认传’undefine’, *这里值得注意的一点是，但定义的函数需要一个参数，但是事件绑定的时候没有加括号，vue会默认将浏览器产生的event事件对象作为参数传到方法 方法定义时，我们需要event对象，同时也要其他参数 @click=&quot;btnclick(&#39;abc&#39;,$event)&quot;,手动获取浏览器参数的event对象，用$event,这里还需要注意的一点是参数&#39;abc&#39;如果不加单引号，会把它当做变量，如果没找到它，就会报错。 2.解决事件冒泡1234&lt;div @click=&quot;divclick&quot; id=&quot;app&quot;&gt; aaaa &lt;button @click=&quot;btnclick&quot;&gt;按钮&lt;/button&gt;&lt;/div&gt; 事件冒泡问题，点击按钮的时候，也会触发其父元素绑定的点击事件 使用.stop修饰符就可以解决 1234&lt;div @click=&quot;divclick&quot; id=&quot;app&quot;&gt; aaaa &lt;button @click.stop=&quot;btnclick&quot;&gt;按钮&lt;/button&gt;&lt;/div&gt; 3.v-on的其他修饰符.prevent,阻止默认事件 @keyup.enter 监听某个键盘的键帽（这里是回车键） .once 点击回调只会触发一次 三、条件判断v-if=&quot;isshow&quot;根据isshow的值判断该标签的内容是否显示，v-else当isshow为false时该标签显示 案例小问题 1234567891011&lt;span v-if=&quot;isUser&quot;&gt; &lt;label for=&quot;username&quot;&gt;用户账号&lt;/label&gt; &lt;!-- &lt;input type=&quot;text&quot; id=&quot;username&quot; placeholder=&quot;用户账号&quot; &gt; --&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; placeholder=&quot;用户账号&quot; key=&quot;username&quot;&gt;&lt;/span&gt;&lt;span v-else&gt; &lt;label for=&quot;email&quot;&gt;用户邮箱&lt;/label&gt; &lt;!-- &lt;input type=&quot;text&quot; id=&quot;email&quot; placeholder=&quot;用户邮箱&quot;&gt; --&gt; &lt;input type=&quot;text&quot; id=&quot;email&quot; placeholder=&quot;用户邮箱&quot; key=&quot;email&quot;&gt;&lt;/span&gt;&lt;button @click=&quot;isUser = !isUser&quot;&gt;切换类型&lt;/button&gt; 这个案例时通过v-if,v-else来切换类型，但是你输入一个数值，再切换类型，输入的数值并不会改变，虽然这个特性有一些开发正好需要这个功能，但视频老师解析了一下，Vue在进行dom渲染时，出于性能考虑，会尽可能复用已经存在的元素，而不是创建新的元素，这里有一个虚拟dom的概念，vue会把要渲染的东西通过虚拟dom放到内存里面。 重点：加一个key就可以解决这个问题，key值相同，就代表是可以复用的，不同就代表不可以复用v-if,当条件为false,包含v-if指令的元素，根本不会存在在dom内 v-show当条件为false,v-show只是给我们的元素添加一个行内样式display：none,元素还是在dom内 __使用__：需要在 显示和隐藏之间频繁切换时，用v-show,一次切换时，用v-if(用的较多) 四、v-for1.在遍历对象的过程中，如果只获取一个值，那么获取的是value 2.&lt;li v-for=&quot;(value,key) in object&quot;&gt;`获取value和key 3.``&lt;li v-for=”(value,key,index) in object”&gt;&lt;/li&gt;获取value,key,index 4.官方推荐我们在使用v-for时，给对应的元素或者组件添加了一个:key属性（好像和链表有有关，但是没太理解，性能为啥优化了）key值和元素一一对应的时候，在插入删除元素时，就不会像链表插入那样很麻烦的移动，而是能够根据key值，找到原来的那个元素，直接复用了，提高性能 五、数据是响应式的（数组为例）letters: [&#39;a&#39;,&#39;b&#39;,&#39;g&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;]给按钮绑定点击事件*this*.letters[1] = &#39;aaaaaaa&#39;; 可以看到：通过索引值修改数组中的元素，不是响应式的（vue没有监听？），即浏览器页面不会重新渲染，但是数组确实发生了变化 数组提供了很多方法都是响应式的 12345678910111213141516171819202122//push方法，在数组最后面添加一个元素// this.letters.push(&#x27;sss&#x27;);//pop方法，删除数组最后一个元素//this.letters.pop()//方法shift()，删除数组第一个元素//this.letters.shift()//unshift()//在数组最前面添加元素,可以多个//this.letters.unshift(&#x27;你好呀&#x27;,&#x27;沙雕&#x27;);//splice(),可以删除元素，插入元素，替换元素//只传第一参数，表示从第几个元素开始全部删除//第二个参数传&#x27;0&#x27;,后面跟上几个参数，表示从第一个参数索引后面插入这几个元素//this.letters.splice(1,0,&#x27;a&#x27;,&#x27;b&#x27;)//第二个参数不传&#x27;0&#x27;,传一个数，后面跟跟上几个参数，代表替换元素（可以理解为先删后插）//this.letters.splice(1,2,&#x27;a&#x27;,&#x27;b&#x27;)//this.letters.sort()数组元素排序//this.letters.reverse()颠倒数组元素//slice(start,end):用于截取数组，并返回截取到的新的数组//必需，规定从何处开始选取，如是负数，规定从数组尾部开始算起，也就是说，-1指的是最后一个元素，-2指倒数第二个元素，依此类推//split():切割字符串，将字符串转化为字符串数组//[1, 2, 3].concat([4, 5, 6]);// 返回新数组 [1, 2, 3, 4, 5, 6]//对数组来说，在一个数组上调用concat方法，然后提供另一个数组作为参数添加到第一个数组末尾，返回一个新数组，不会改变任何一个原始数组。 Vue提供的set方法也能做到*Vue.set(this.letters,2,&#39;bbbbbbb&#39;);* 参数一：要修改的对象 参数二：索引值 参数三：修改后的值 调用了响应式后，通过索引改变的值，也渲染出来了（借势？狗头） 六、高阶函数1.filter函数 filter函数返回的结果是一个新的数组，参数是一个函数，也就是回调函数，会对数组元素逐个遍历，回调函数必须返回一个boolean值，boolean值为true时，函数内部会自动的将这次回调的n加入到新的数组中，如果为false,函数内部会过滤掉这次的n. 12345const nums = [10,20,111,222,444,40,50];let newnums = nums.filter(function(n) &#123; return n &lt;100;&#125;)console.log(newnums); 输出结果如图： 2.map函数map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 12345const nums = [10,20,111,222,444,40,50];let newnums = nums.map(function(n) &#123; return n*2;&#125;)console.log(newnums); 输出结果如下： 1234567891011var array1 = [1, 4, 9, 16]; const map1 = array1.map(x =&gt; &#123; if (x == 4) &#123; return x * 2; &#125; //在这里加上一句return x;就可以了&#125;); console.log(map1);//Array [undefined, 8, undefined, undefined] 这样写只是增加了一个条件，即x的值为4时才乘以2，之所以会出现undefined，是因为map()方法创建了一个新数组，但新数组并不是在遍历完array1后才被赋值的，而是每遍历一次就得到一个值 和filter函数很相似，但是弹幕说，一个是过滤，一个是映射 3.reduce函数12345const nums = [10,20,111,222,444,40,50];let newnums = nums.reduce(function(preValue,n) &#123; return preValue+n;&#125;,0)console.log(newnums); reduce函数有两个参数，第一个是一个回调函数，回调函数中两个参数，preValue是前一次回调的返回值，n是这一次遍历的数组元素，reduce的第二个参数是preValue的默认值，因为第一次遍历时，没有前一次回调的返回值，所以需要默认一个 输出结果如图： 七、v-model1.理解实现数据的双向绑定&lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;就等于 1&lt;input type=&quot;text&quot; v-bind:value=&quot;message&quot; v-on:input = &quot;message = $event.target.value&quot;&gt; input的input事件（狗头），有点拗口。这里也可以管中窥豹一下，v-model绑定的是value值 2.结合radio使用复习知识： 1.label标签 for里面的内容，对应哪个input的id,label标签里面的内容被点击，该input就会获得焦点 2.拥有相同的name值，就会互斥，表单提交只能提交一个 123456&lt;label for=&quot;male&quot;&gt; &lt;input type=&quot;radio&quot; id=&quot;male&quot; value=&quot;男&quot; name=&quot;sex&quot;&gt;男&lt;/label&gt;&lt;label for=&quot;female&quot;&gt; &lt;input type=&quot;radio&quot; id=&quot;female&quot; value=&quot;女&quot; name=&quot;sex&quot;&gt;女&lt;/label&gt; 利用v-model,可以不设置name,也会互斥 123456&lt;label for=&quot;male&quot;&gt; &lt;input type=&quot;radio&quot; id=&quot;male&quot; value=&quot;男&quot; v-model=&quot;sex&quot;&gt;男&lt;/label&gt;&lt;label for=&quot;female&quot;&gt; &lt;input type=&quot;radio&quot; id=&quot;female&quot; value=&quot;女&quot; v-model=&quot;sex&quot;&gt;女&lt;/label&gt; data:&#123;sex: &quot;男&quot;&#125; 3.结合checkbox复习：可以理解为checkbox的value就两个值true(选中)/false(没选中) 12345&lt;input type=&quot;checkbox&quot; value=&quot;篮球&quot; v-model=&quot;hobbies&quot;&gt;篮球&lt;input type=&quot;checkbox&quot; value=&quot;足球&quot; v-model=&quot;hobbies&quot;&gt;足球&lt;input type=&quot;checkbox&quot; value=&quot;乒乓球&quot; v-model=&quot;hobbies&quot;&gt;羽毛球&lt;input type=&quot;checkbox&quot; value=&quot;羽毛球&quot; v-model=&quot;hobbies&quot;&gt;乒乓球&lt;h2&gt;您选择的爱好有：&#123;&#123;hobbies&#125;&#125;&lt;/h2&gt; data:&#123;hobbies: []&#125; 输出结果如图： 注意：checkbox绑定的是数组 4.结合select(1)单选1234567&lt;select name=&quot;abc&quot; id=&quot;&quot; v-model=&quot;fruit&quot;&gt; &lt;option value=&quot;苹果&quot;&gt;苹果&lt;/option&gt; &lt;option value=&quot;香蕉&quot;&gt;香蕉&lt;/option&gt; &lt;option value=&quot;榴莲&quot;&gt;榴莲&lt;/option&gt; &lt;option value=&quot;葡萄&quot;&gt;葡萄&lt;/option&gt;&lt;/select&gt;&lt;h2&gt;您选择的水果有：&#123;&#123;fruit&#125;&#125;&lt;/h2&gt; data:&#123;fruit: &quot;香蕉&quot;&#125;,结果如图： （2）多选1234567&lt;select name=&quot;abc&quot; v-model=&quot;fruits&quot; multiple&gt; &lt;option value=&quot;苹果&quot;&gt;苹果&lt;/option&gt; &lt;option value=&quot;香蕉&quot;&gt;香蕉&lt;/option&gt; &lt;option value=&quot;榴莲&quot;&gt;榴莲&lt;/option&gt; &lt;option value=&quot;葡萄&quot;&gt;葡萄&lt;/option&gt;&lt;/select&gt;&lt;h2&gt;您选择的水果有：&#123;&#123;fruits&#125;&#125;&lt;/h2&gt; data:&#123;fruits:[]&#125;记住了，多选的时候要按住ctrl键哦 结果如下： 5.v-model修饰符（1）lazy默认情况下，v-model是在input事件中同步输入框的数据，lazy修饰符可以让数据在失去焦点或者回车时才更新 12&lt;input type=&quot;text&quot; v-model.lazy=&quot;message&quot;&gt;&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt; (2)number默认情况下，在输入框无论我们输入的是字母还是数字，都会被当做字符串类型进行处理，number修饰符可以让输入框中输入的内容，自动转化成数字类型 12&lt;input type=&quot;text&quot; v-model=&quot;age&quot;&gt;&lt;div&gt;&#123;&#123;age&#125;&#125;----&#123;&#123;typeof age&#125;&#125;&lt;/div&gt; 不使用number修饰符时结果如图： 12&lt;input type=&quot;text&quot; v-model.number=&quot;age&quot;&gt;&lt;div&gt;&#123;&#123;age&#125;&#125;----&#123;&#123;typeof age&#125;&#125;&lt;/div&gt; 使用number修饰符时结果如图： （3）trim可以过滤内容左右两边的空格 12&lt;input type=&quot;text&quot; v-model.trim=&quot;age&quot;&gt;&lt;div&gt;&#123;&#123;age&#125;&#125;&lt;/div&gt; 结果如图： 八、组件化（重点）步骤：1.创建组件构造器对象 12345678const cpnC = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h2&gt;我是标题&lt;/h2&gt; &lt;p&gt;我是内容&lt;/p&gt; &lt;p&gt;我才是内容，你是假的&lt;/p&gt; &lt;/div&gt;`&#125;) 2.注册组件 全局组件，意味着可以在多个Vue的实例下面使用 Vue.component(‘my-cpn’,cpnC)` components: {cpn: cpnC}//cpn是使用组件时的标签名，cpnC是上面组件构造器的名字， 常用的是全局组件，开发中也通常只有一个Vue实例 语法糖形式注册组件 (全局的):可以直接使用标签，实质上也是调用了extend() 12345678Vue.component(&#x27;cpn1&#x27;,&#123; template: ` &lt;div&gt; &lt;h2&gt;我是标题1&lt;/h2&gt; &lt;p&gt;我是内容&lt;/p&gt; &lt;p&gt;我才是内容，你是假的&lt;/p&gt; &lt;/div&gt;`&#125;) (局部的) 12345678910components: &#123; &#x27;cpn2&#x27;: &#123; template: ` &lt;div&gt; &lt;h2&gt;我是标题2&lt;/h2&gt; &lt;p&gt;我是内容&lt;/p&gt; &lt;p&gt;我才是内容，你是假的&lt;/p&gt; &lt;/div&gt;` &#125;&#125; 3.使用 123&lt;div id=&quot;app&quot;&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt;&lt;/div&gt; 注意：1,2步要放在创建Vue对象的前面，不然报错，暂时不知道why,组件必须挂在到某个Vue实例下，否则他不会生效 父子组件1234567891011121314151617181920const cpnC1 = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h2&gt;我是标题1&lt;/h2&gt; &lt;p&gt;我是内容&lt;/p&gt; &lt;p&gt;我才是内容，你是假的&lt;/p&gt; &lt;/div&gt;` &#125;) const cpnC2 = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h2&gt;我是标题2&lt;/h2&gt; &lt;p&gt;我是内容&lt;/p&gt; &lt;p&gt;我才是内容，你是假的&lt;/p&gt; &lt;cpn1&gt;&lt;/cpn1&gt; &lt;/div&gt;`, components: &#123; cpn1:cpnC1 &#125; &#125;) 在cpnC2里面注册组件cpnC1，所以可以在cpnC2里面使用cpnC1，但是不能再其他地方使用，想要在别的地方使用，就在该地方注册一下，而且Vue实例，可以看做是一个root组件，cpnC2就是在该组件注册 components: &#123; cpn2: cpnC2&#125; 组件模板抽离1234567&lt;script type=&quot;text/x-tempalte&quot; id=&quot;cpn&quot;&gt;&lt;div&gt; &lt;h2&gt;你是个小傻逼&lt;/h2&gt; &lt;h2&gt;你才是个小傻逼&lt;/h2&gt;&lt;/div&gt;&lt;/script&gt; 123Vue.component(&#x27;cpn&#x27;,&#123; template: &quot;#cpn&quot;&#125;) -– title: HTML入门笔记 copyright: truedate: 2018-11-23 21:07:15 toc: truetags: [HTML,前端]categories: [前端,HTML]-–"}],"posts":[{"title":"","slug":"CC培训学习心得","date":"2020-12-11T16:10:27.002Z","updated":"2020-12-13T15:00:14.464Z","comments":true,"path":"2020/12/12/CC培训学习心得/","link":"","permalink":"http://example.com/2020/12/12/CC%E5%9F%B9%E8%AE%AD%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/","excerpt":"","text":"CC学习心得12/111查看请求头 .按F12 2.network 3.xhl 4.刷新页面 5.点击要查看的请求 2.学长的代码里面有一个，尖括号里面加%，然后好像还用了for循环，不知道是干啥的 3.http协议就是 tcp协议加一些自定义的东西？ 12/121.函数声明的两种方式（1）函数表达式let aaa = function()&#123;.....&#125; (2) 函数声明 function bbb()&#123;.....&#125; 函数声明可以提前被解析出来，表达式不行，所以函数声明的函数可以在执行任何代码之前访问，但是函数表达式提前调用会报错。（自己实验过） 当同时用这两种方式声明同一个函数名，最终执行的是函数表达式声明的函数（自己实验过，函数表达式用var确实是这样的，但是用let就会报错，说这个函数已经声明过了） 1234567let a = function()&#123; console.log(&quot;123&quot;);&#125;function a()&#123; console.log(&quot;456&quot;);&#125;a(); 2.javascript里面的this是啥(1)一般函数中的this(已实验过)12345//&quot;use strict&quot;function a()&#123; console.log(this);&#125;a(); 非严格模式下，函数中的this指向全局对象window,window上挂了很多属性方法 严格模式下，函数中的this为undefined （2）对象方法中的this（已实验过）对象中的this指向调用此方法的对象 12345678910let a = &#123; x:0, y:0, fun1: function(x,y)&#123; this.x=x; this.y=y; &#125;&#125;a.fun1(9,9);console.log(a);//输出&#123;x: 9, y: 9, fun1: ƒ&#125; 方法中存在函数嵌套 12345678910111213141516171819202122let a = &#123; x:0, y:0, fun1: function(x,y)&#123; let that = this; //将fun1的this(对象a)给that，这种方法之前在用vue写课表查询， //在函数内使用axios时用过 function fun2(x)&#123; //这样就可以在嵌套的函数内调用到x that.x = x; &#125;; function fun3(y)&#123; //有嵌套的情况，嵌套函数里面this指向window this.y = y; &#125;; fun2(x); fun3(y); &#125;&#125;;a.fun1(9,9);console.log(a);//输出&#123;x: 9, y: 0, fun1: ƒ&#125;console.log(window.x+&#x27; &#x27;+window.y);//输出undefined 9 (3)构造函数中的this（已实验过） 调用构造函数时，会将this绑定到新创建的对象上 12345678function Point(x,y)&#123; this.x = x; this.y = y;&#125;let p = new Point(9,9);Point(1,1);console.log(p);//输出Point &#123;x: 9, y: 9&#125;console.log(window.x,window.y);//输出1 1 （4）间接调用this(call,apply，bind这三方法都是定义在原型上的)(已实验过)12345678910111213141516171819202122 let a = &#123; x: 1, y: 2, fun1: function()&#123; console.log(this.x,this.y); &#125; &#125; let b = &#123; x: 3, y: 4, fun1: function()&#123; console.log(this.x,this.y); &#125; &#125;//三个方法都是将某个函数的this指向修改为传入这三个方法的第一个参数 a.fun1();//1 2 b.fun1();//3 4 a.fun1.call(b);//3 4 b.fun1.call(a);//1 2 a.fun1.apply(b);//3 4 b.fun1.apply(a);//1 2 a.fun1.bind(b)();//3 4//bind返回的是一个函数，需要调用才能执行fun1方法 传参数时是这样的 123456789101112131415161718192021let aa = &#123; x: 1, y: 2, fun1: function(a,b)&#123; console.log(a,b); &#125;&#125; let bb = &#123; x: 3, y: 4, fun1: function(a,b)&#123; console.log(a,b); &#125;&#125;function A(aa,bb)&#123; this.aa = aa; this.bb = bb;&#125;//下面全部输出11 22aa.fun1.call(bb,11,22);//第一，参数是传给调用call等方法这个函数的aa.fun1.apply(bb,[11,22]);//第二、apply将要传的参数放到一个数组里面作为第二个参数aa.fun1.bind(bb,11,22)(); 5.原型与原型链（一张网图，很清晰）（已实验过）原型：每一个除了null以外的javascript对象创建的时候都会关联一个对象，这个对象就是原型，每一个对象都会从原型中‘继承’属性 创建对象let a = new Object();要记得函数也是对象，就连原型也是对象（万物皆对象狗头） 12345678910111213141516function A(x) &#123; this.x = x;&#125;//a是A的实例，a本身是没有y这个属性的，是继承自A.prototypeA.prototype.y = 10; var a = new A(20); console.log(a.y,a.x);//10 20 console.log(A.prototype === a.__proto__);//true //__proto__是实例指向原型的属性 //prototype是构造函数指向原型的属性 console.log(A.prototype.constructor === A);//true //constructor是原型的属性，指向与之关联的构造函数 console.log(a.constructor === A);//true //a上面没有construtor属性，只能到原型上去找，恰好原型(A.prototype)上有这个属性，并指向A let b = new Object();//这里Object可以理解为构造函数 console.log(Object.prototype.__proto__ === null);//true //Object.prototype没有原型了，就是最顶层了，再找不到就是没有该属性了 当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。这样就形成了原型链 12345678910function A(x) &#123; this.x = x;&#125;A.prototype.y = 10; let a = new A(20); let b = a; let c = b; console.log(b.__proto__ === A.prototype);//true console.log(b.__proto__ === c.__proto__);//true console.log(c.__proto__ === A.prototype);//true 上面就是一条原型链了，实例化构造函数，再赋值赋值c-&gt;b-&gt;a-&gt;A 4.闭包js（es5）只有函数作用域函全局作用域的概念，闭包就是能够读取其他函数内部变量的函数，因为只有函数内部的函数能够读取局部变量，闭包就是函数内外部连接的一个接口 123456789101112131415var local = 1;function foo() &#123; var local = 1; function bar() &#123; local++; return local; &#125; return bar;&#125;var f1 = foo();console.log(f1());//2console.log(f1());//3var f2 = foo();//新定义的函数，和上面那个是隔开的的，所以下面输出的是2，而不是4console.log(f2());//2console.log(&#x27;local&#x27;, local);//1 没有闭包作为接口，只能访问到全局变量local 在函数foo执行完并返回后，闭包使得JavaScript的垃圾回收机制不会收回foo所占用的资源，因为foo的内部函数bar的执行需要依赖foo中的变量，闭包需要循序渐进的过程。 JavaScript的回收机制去了解一下 滥用闭包会造成内存泄露，因为闭包中引用到的包裹函数中定义的变量都永远不会被释放，所以我们应该在必要的时候，及时释放这个闭包函数。 5.实现原生bind 6.科里化作用，返回一个函数，这个函数还能够再接受一个参数，做到了复用参数 *","categories":[],"tags":[]},{"title":"","slug":"Flex布局学习","date":"2020-12-06T11:42:03.652Z","updated":"2020-12-13T09:51:46.505Z","comments":true,"path":"2020/12/06/Flex布局学习/","link":"","permalink":"http://example.com/2020/12/06/Flex%E5%B8%83%E5%B1%80%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Flex布局学习一、开启flex布局display:flex（）块元素或者display:inline-flex(行内元素) 块级元素会独占一行 flex布局有主轴和交叉轴的概念，开启了flex布局的元素为constainer,里面的元素为items 行内元素一般不能设置宽高，需开启定位或者转块级元素 1.应用在flex constainer 上的css属性：（1）、. flex-flow是flex-direction||flex-wrap的简写，顺序 （2）、.flex-direction 元素布局默认是沿着主轴从main start 到main end方向排 （给一个标签同时设置多个类，用空格隔开class=&quot;items item1&quot;） 没有开启flex布局时，是这样的： 开启了flex布局后就是这样的： 取值：row（默认值）:主轴从左到右 ​ row-reverse:主轴从右到左 ​ columu:主轴从上到下： ​ columu-reverse:主轴从下到上 （3）、.flex-wrap默认(nowrap)情况下，所有的items都会在同一行显示，放不下就会压缩 取值：wrap wrap-reverse反转，用的很少 （4）、.justify-content决定itmes主轴的对齐方式 取值：flex-start(默认值) ​ flex-end:与main end（主轴末端）对齐 ​ center:居中对齐 ​ space-between （等分）space-evenly： ​ 两边为中间的一半space-around （5）、.align-items决定items在cross（交叉轴）上的对齐方式 没有给items设置高度时，stretch会直接在constainer里面拉满 给itmes高度设置不一样： align-items: flex-end好像理解为，constainer只有一行了（end对齐方式）; align-items: *center*;中心对齐 基准线对齐：align-items: baseline看第一行文本; .align-content决定多行items在交叉轴上的对齐方式，与justify-content类似 取值：stretch(默认值)，没设置高度会有拉升效果，与align-items的stretch类似 flex-start：从交叉轴开始依次排开! flex-end:从交叉轴结尾依次排开（这个或许有一丢丢难理解，前面5个盒子在最后一行开始排队，后面放不下了，他们上去，下面是我继续排 flex-center:居中 space-between: space-around:与justify-content相似，往上翻 space-evently: 应用在flex items上的css属性_flex-basis决定items在main主轴方向上的base size（宽度） .flex-shrik决定了items是如何收缩的（当items的总长度大于container的长度时会默认收缩items,当然你也可以设置换行） .flex-grow.决定了items如何扩展 注：只有在container在main主轴方向上有剩余的size时，flex-grow属性才会生效 可以设置任意非负数字，默认为 0， **1.**如是所有items的flex-grow综合sum超过1， 则每个items扩展为：container剩余size*flex-grow/sum **2.**如是所有items的flex-grow综合sum不超过1， 则每个items扩展为：container剩余size*flex-grow order:决定了items的排布顺序，可以设置任意整数，值越小就越在前面 **2.**如是所有items的grow总和不超过1，每个items扩展为container flex-shrink .order决定items排布的顺序。设置任意整数，值越小越排前面 .align-self align-self可以通过它来覆盖constainer设置的align-items flex:是flex-grow||flex-shrink||flex-basis的简写，可以指定1||2||3个值（了解就行） 清除浮动（在父元素里面写） 1.给父元素设置固定高度 2.clear-flx清除浮动","categories":[],"tags":[]},{"title":"","slug":"课表查询项目中遇到的问题","date":"2020-12-05T01:54:18.844Z","updated":"2020-12-06T06:53:16.976Z","comments":true,"path":"2020/12/05/课表查询项目中遇到的问题/","link":"","permalink":"http://example.com/2020/12/05/%E8%AF%BE%E8%A1%A8%E6%9F%A5%E8%AF%A2%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"课表查询项目中遇到的问题1.用原生js获取input输入框内容的时候， let department = document.getElementById(&quot;department&quot;).value;这样获取不到，必须let department = document.getElementById(&quot;department&quot;)然后用的时候手动加.value 2.尝试用vue，一开始就报错&lt;td v-model=&quot;text2&quot;&gt;: v-model is not supported on this element type 失误了，一查官方文档才明白 我擦，对使用的标签有限制的，呜呜呜 3.vue中this的问题（+1） 12345678910111213analyze() &#123; //这个步骤真的异常关键 var _this = this; axios.get(`./json_modify/2019软件工程4班.json`) .then(function(res) &#123; for(let i=0;i&lt;res.data.Monday.length;i++)&#123; _this.Monday.splice(i,1,res.data.Monday[i]); // _this.Monday = res.data.Monday &#125; &#125;)&#125;//这个味this必须转换一下，得研究研究 4.如何获取输入框和下拉款的值，用v-model双向绑定即可 5.换了个思路，按条件找对象，之前按顺序太蠢了，用find函数找对象时，就因为 let number = *this*.test.find(item =&gt; &#123;item &gt; 2&#125; );我给箭头函数加了个括号，就查询不到，没加括号就查询到了``let number = *this*.test.find(item =&gt; item &gt; 2 ); 123&lt;td v-for&#x3D;&quot;(week,index1) in weeks&quot;&gt; &lt;p v-for&#x3D;&quot;(item,index2) in classOder&quot; v-show&#x3D;&quot;Monday[index2].section &#x3D;&#x3D; 1&quot;&gt;&#123;&#123;week[index2].course_name&#125;&#125;&lt;&#x2F;p&gt;&lt;&#x2F;td&gt;","categories":[],"tags":[]},{"title":"","slug":"Vue小项目实例","date":"2020-12-03T04:04:18.186Z","updated":"2020-12-03T08:16:43.268Z","comments":true,"path":"2020/12/03/Vue小项目实例/","link":"","permalink":"http://example.com/2020/12/03/Vue%E5%B0%8F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E4%BE%8B/","excerpt":"","text":"Vue小项目实例1.对列表元素实现，点击哪一个就将该列表项变红完整代码：&quot;E:\\笔记\\resource\\item1.html&quot; 觉着比较巧妙的是，利用了一个currentactive来记录状态，根据事件修改它的状态来实现功能 2.类似于购物车的功能完整代码：&quot;E:\\笔记\\resource\\item2.html&quot;","categories":[],"tags":[]},{"title":"","slug":"ES6学习笔记","date":"2020-11-30T13:42:58.271Z","updated":"2020-12-13T15:26:48.291Z","comments":true,"path":"2020/11/30/ES6学习笔记/","link":"","permalink":"http://example.com/2020/11/30/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"ES6学习笔记一、var let const1.var:没有块级作用域123456var btns = document.getElementsByTagName(&#x27;button&#x27;);//一共5个按钮for(var i =0;i&lt;btns.length;i++)&#123; btns[i].addEventListener(&#x27;click&#x27;,function()&#123; console.log(&quot;第&quot;+i+&quot;按钮被点击！&quot;); &#125;)&#125;//点击第一个按钮，输出“第5个按钮被点击” 是因为在for循环执行完，事件绑定也绑定完了，但是函数没被立即执行，当函数触发时，i已经+到5了 以前学的用闭包可以解决：(es5之前，if和for都没有块级作用域的概念，但函数是有作用域的，所以经常借助函数的作用域来解决应用外面变量的问题) 12345678var btns = document.getElementsByTagName(&#x27;button&#x27;);for(var i =0;i&lt;btns.length;i++)&#123; (function(i)&#123;btns[i].addEventListener(&#x27;click&#x27;,function()&#123; console.log(&quot;第&quot;+i+&quot;按钮被点击！&quot;); &#125;) &#125;)(i)&#125;//按我的理解，这里就是创建了5个立即执行函数，每个函数对应的i不同，也互不干扰 2.es6中let作用域的（if和for）123456ar btns = document.getElementsByTagName(&#x27;button&#x27;);//一共5个按钮for(let i =0;i&lt;btns.length;i++)&#123; btns[i].addEventListener(&#x27;click&#x27;,function()&#123; console.log(&quot;第&quot;+i+&quot;按钮被点击！&quot;); &#125;)&#125;//只需要将for循环里面的var改成let就可以了 用var就相当于在for循环外面定义了一个var i=0,5次事件绑定的回调函数共用一个i，用let的话，i只在自己的作用域内有效，一次++循环过去了，就换了个作用域，自己就不起作用了，当然i++就会有一个新的i对应这个作用域。 3.const 建议使用const,除非该标识符需要改变就用let(1)一旦给const修饰的标识符赋值之后，不能再修改const ldp = &#39;大帅比&#39;; ldp = &#39;小丑比&#39; 给报错了 (2)常亮的含义是指定的对象不能修改（指针不能修改），但是可以改变对象内部的属性12345const obj = &#123;name: &#x27;ldp&#x27;,age: 19, height:175 &#125;console.log(obj)obj.age = 22obj.name = &#x27;lf&#x27;obj.height = 178// obj.wight = 70;obj.work = &#x27;student&#x27; 可以被改变 添加属性也可以 const obj = &#123;name: &#39;ldp&#39;,age: 19, height:175 &#125;; obj = &#123;name:&#39;yiqi&#39;&#125;这样子就是不可以 理解：obj对象储存的是各个属性的地址位置，这些地址就存了各个属性值，我们改变属性的值，没有改变地址，同样，增加属性，也没有改变地址位置，但是删除一些属性就是改了就是改了。 字面量增强const name = &#39;小可爱&#39;;const age = 19;const obj = &#123;name,age&#125;; const obj = {fun() {},fun2() {}}这是ES6的函数增强写法，在对象里面放函数，直接这么写就可以了`","categories":[],"tags":[]},{"title":"","slug":"git初体验","date":"2020-11-28T12:23:11.781Z","updated":"2020-11-28T12:26:07.467Z","comments":true,"path":"2020/11/28/git初体验/","link":"","permalink":"http://example.com/2020/11/28/git%E5%88%9D%E4%BD%93%E9%AA%8C/","excerpt":"","text":"git初体验1.常用git命令git branch 查看本地所有分支 git init 本地初始化 git status 查看当前状态 git commit 提交 git diff 比较文件 git push origin master 将文件给推到服务器上 git rm 文件名(包括路径) 从git中删除指定文件 git clone git://github.com/schacon/grit.git 从服务器上将代码给拉下来 2.使用大致流程1.git init 在空目录文件使用该命令，初始化本地仓库 2.设置签名，一般使用全局（–global）的就好了,名字和邮箱不一定要和github一样，只是起验证作用 git config user.name 名字 git config user.email 邮箱 或者 git config –global user.name 名字 git config –global user.email 邮箱 3.git clone 地址 4.git push 地址 分支 另外给我记好了，部署博客的时候在blog根目录下面敲下面这些命令 hexo clean hexo g hexo d","categories":[],"tags":[]},{"title":"","slug":"解析JSON文件实现查询系列","date":"2020-11-28T11:41:04.254Z","updated":"2020-11-28T11:41:05.005Z","comments":true,"path":"2020/11/28/解析JSON文件实现查询系列/","link":"","permalink":"http://example.com/2020/11/28/%E8%A7%A3%E6%9E%90JSON%E6%96%87%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%9F%A5%E8%AF%A2%E7%B3%BB%E5%88%97/","excerpt":"","text":"解析JSON文件实现查询系列1.利用axios解析1234&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/axios/0.21.0/axios.min.js&quot;&gt;&lt;/script&gt;//首先引用axios的CDNaxios.get(&quot;这里写json格式文件的路径&quot;).then(function(res)&#123;&#125;).catch()//解析后的内容在res.data就可以得到","categories":[],"tags":[]},{"title":"","slug":"TodoList 总结","date":"2020-11-28T11:24:47.775Z","updated":"2020-11-28T11:24:20.610Z","comments":true,"path":"2020/11/28/TodoList 总结/","link":"","permalink":"http://example.com/2020/11/28/TodoList%20%E6%80%BB%E7%BB%93/","excerpt":"","text":"TodoList 总结 首先提醒自己时刻记住代码规范，从属关系，缩进整明白，不然自己和别人都看着烦 一、Dom~动态创建删除元素想实现这样一个功能：双击列表项能够实现对列表项的改动 思路：双击后，在列表项li里面创建一个input输入框，将列表项原本的文本内容赋给input作为默认值,再将列表项文本内容删除。用户修改input输入框里面的内容（获取焦点），用户修改完毕后（失去焦点）将input的value值赋给列表项，再删除input 1234567891011let oldhtml = element.firstChild.nodeValue;//获取元素之前的内容let newobj = document.createElement(&#x27;input&#x27;);//创建一个input元素newobj.type = &#x27;text&#x27;;newobj.value = oldhtml;element.firstChild.nodeValue = &#x27;&#x27;;//设置元素内容为空element.appendChild(newobj);//若报错Cannot read property &#x27;appendChild&#x27; of null。一般是获取的节点不存在newobj.focus()//获取焦点newobj.onblur = function () &#123;element.firstChild.nodeValue = newobj.value;newobj.remove(); 注：想让效果更好的话，要设置input的样式，另外频繁操作dom,似乎似乎会对cpu造成较大压力，具体较好的解决方法，带我学了新知识再来解决！ 二、空格，null ,undefine我需要判断input输入框输入的内容，来决定是否允许提交，用空格todo.value ===&#39;&#39; 1234null===undefined //falsenull==undefined//trueNumber(null)//0Number(undefined)//NaN null表示一个值被定义了，是空值 undefined表示缺少值，还未定义 三、清空我要实现一个清空列表项的功能 思路1. list.remove();//这种方法不好，直接删除了ol,再重新增加li就没地方增加了，应为ol都没有了 思路2.循环删除li，也不好，因为删除一个后子节点们会重新排列，最后不能实现清空的功能 思路3.123while(list.hasChildNodes())&#123; list.removeChild(list.firstChild);&#125;//这是在网上看到的 四、错误在写代码的过程中经常会遇到类似于Cannot read property ‘appendChild’ of null这样的错误，一般就是没有找到节点啥的，在这里，温习一下，页面渲染的顺序","categories":[],"tags":[]},{"title":"","slug":"实践问题之CSS布局","date":"2020-11-27T12:02:02.581Z","updated":"2020-12-03T09:53:05.814Z","comments":true,"path":"2020/11/27/实践问题之CSS布局/","link":"","permalink":"http://example.com/2020/11/27/%E5%AE%9E%E8%B7%B5%E9%97%AE%E9%A2%98%E4%B9%8BCSS%E5%B8%83%E5%B1%80/","excerpt":"","text":"实践问题之CSS布局一、浮动1、给列表项设置浮动，想让他们向右排列，但是顺序反了。再来改变标签排列顺序就会很麻烦，看起来也比较蠢，搜了下解决方法： 给顺序倒转的元素添加一个父元素，使得父元素向所需方向浮动，子元素反方向浮动 二、垂直居中的集中常见方法1.123display: table-cell;/*让标签元素以表格单元格的形式呈现，使得元素类似于td标签*/vertical-align: middle;/*可以理解为将元素放置在父元素的中部*/text-align: center;/*设置文本对齐的方式，对行内元素也起作用 2.开启定位123position: absolute;/*给父元素开启相对定位，给子元素开启绝对定位，设置偏移量*/top: 25%;left: 25%; 3.设置偏移量为0123456position: absolute;&#x2F;*有点 神奇，也是不知道为什么*&#x2F;margin: auto;top: 0;left: 0;right: 0;bottom: 0; 4.flex 但是flex布局和浮动不能同时作用一个对象，自己还不熟悉flex,就先不用 二、定位（position）1.绝对定位（absolute） 绝对定位是相对于元素最近的已定位（开启了定位）的祖先元素，如果没有已经定位的祖先元素，则位置相对于最初的包含块（html）。脱离了文档流，原来的位置就是空的了，下面的元素就会来占据位置 2.相对定位(relative) 相对于元素在文档中的初始位置，但是无论是否移动，元素都会占据原来的位置(元素仍然处于文档流中) 三、边框我今天给table设置边框的时候 border: 1px *solid* #e9e9e9;居然在中间加逗号，忘记是空格，然后样式就是没效果，排查了好久，要被自己蠢哭了~","categories":[],"tags":[]}],"categories":[],"tags":[]}